 import Foundation@objc(MyAllPluginsClass) class MyAllPluginsClass : CDVPlugin,protocal_for_plugins {                    func MyAllPluginsMethod(_ command: CDVInvokedUrlCommand!) {        var xx = command.arguments[0] as! String       print( "kkkkkkkkkk" + xx)     if(command.arguments[0] as! String == "checkUpdate"){        //var instance_class:checkUpdate!=checkUpdate();            var instance_class = checkUpdate();    instance_class.delegateForPlugins = self;    instance_class.checkUpdateFromServer(command.callbackId, args: command.arguments as! NSArray);}        else if(command.arguments[0] as! String == "getDeviceInfo"){    getDeviceInfo(command.callbackId);    }            else if(command.arguments[0] as! String == "showToast"){        self.webView?.makeToast(command.arguments[1] as! String , duration: 5, position: ToastPosition.bottom)    }        else if(command.arguments[0] as! String == "voipPushRequestID"){    var voipTCPService: VoipTCPService = VoipTCPService()           let appDelegate = UIApplication.shared.delegate as! AppDelegate      if #available(iOS 8.0, *) {            appDelegate.voipTCPService.delegateForPlugins=self;          appDelegate.voipRegistration(command.callbackId)      }}        else if(command.arguments[0] as! String == "pushNotification"){        sendNotification(command);    }                if(command.arguments[0] as! String == "moveTaskToBack")    {          UIControl().sendAction(#selector(URLSessionTask.suspend), to: UIApplication.shared, for: nil)    }            }            func sendNotification(_ command:CDVInvokedUrlCommand!)    {        let notification = UILocalNotification()        notification.fireDate = Date(timeIntervalSinceNow: 3)        notification.applicationIconBadgeNumber = notification.applicationIconBadgeNumber + 1;        if #available(iOS 8.2, *) {        notification.alertTitle = command.arguments[1] as! String        }        notification.alertBody = command.arguments[2] as! String        // notification.alertAction = "be awesome!"        notification.soundName = UILocalNotificationDefaultSoundName        // notification.userInfo        //notification.userInfo = ["CustomField1": "w00t"]        UIApplication.shared.scheduleLocalNotification(notification)            }                func getDeviceInfo(_ callBackIdx:String)    {        let device_udid = get_forever_Value_for_key("device_udid");        let device_model =  UIDevice.current.model;        let device_product = UIDevice.current.name;        // let systemName = UIDevice.currentDevice().systemName;        let device_sdk_version =   UIDevice.current.systemVersion                let   device_mac_Addr = "";        let device_serial = "";        let device_android_Id="";        let device_manufacturer="Apple";        //let device_brand=systemInfo.machine        var systemInfo = utsname()        uname(&systemInfo)        let machineMirror = Mirror(reflecting: systemInfo.machine)        let device_brand = machineMirror.children.reduce("") { identifier, element in        guard let value = element.value as? Int8, value != 0 else { return identifier }        return identifier + String(UnicodeScalar(UInt8(value)))        }                 let projectPackageNameBundleID = Bundle.main.bundleIdentifier!                                        let para:NSMutableDictionary = NSMutableDictionary()        ///         para.setValue(device_sdk_version, forKey: "device_sdk_version")         para.setValue(device_model, forKey: "device_model")        para.setValue(device_product, forKey: "device_product")        para.setValue(device_brand, forKey: "device_brand")        para.setValue(device_manufacturer, forKey: "device_manufacturer")        para.setValue(device_android_Id, forKey: "device_android_Id")        para.setValue(device_serial, forKey: "device_serial")        para.setValue(device_udid, forKey: "device_udid")        para.setValue(device_mac_Addr, forKey: "device_mac_Addr")        para.setValue("ios", forKey: "device_os")        para.setValue(projectPackageNameBundleID, forKey: "projectPackageNameBundleID")                // let jsonError: NSError?        let jsonData: Data        do{            jsonData = try JSONSerialization.data(withJSONObject: para, options: JSONSerialization.WritingOptions())            let jsonString = NSString(data: jsonData, encoding: String.Encoding.utf8.rawValue)! as String           // print("json string = \(jsonString)")            call_back_with_success(callBackIdx, message: jsonString);                    } catch _ {           // print ("error UH OOO")            call_back_with_error(callBackIdx, message: "error when parse json in native ios");        }                                                //  get_device_udid();                           // Thread-safe.            }            func get_forever_Value_for_key(_ the_key:String)->String        {                        let defaults = UserDefaults.standard            var forever_key = defaults.string(forKey: the_key)            //            if(forever_key==nil)            {                var temp=Keychain.load(the_key);                if(temp != nil)            {                forever_key  =  temp!.stringValue                }                if(forever_key==nil)//not in Keychain and not in NSUserDefaults so get it and save it        {            forever_key = UIDevice.current.identifierForVendor!.uuidString;            Keychain.save(the_key, data: forever_key!.dataValue)                        UserDefaults.standard.set(forever_key, forKey: the_key)            UserDefaults.standard.synchronize();                                            }            else//in Keychain only so put it in NSUserDefaults        {                UserDefaults.standard.set(forever_key, forKey: the_key)                UserDefaults.standard.synchronize();                                }                            }                                else //in NSUserDefaults so check if in Keychain            {                    let temp=Keychain.load(the_key);                    if(temp != nil)            {                let temp_from_Keychain  =  temp!.stringValue;                if(temp_from_Keychain != forever_key )            {                Keychain.save(the_key, data: forever_key!.dataValue)                }            }                else            {                Keychain.save(the_key, data: forever_key!.dataValue)                    }            }                                    return forever_key!;                }        func call_back_with_success(_ callBackIdx:String,message:String )    {            let pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: message  )            commandDelegate!.send(pluginResult, callbackId: callBackIdx)    }        func call_back_with_error(_ callBackIdx:String,message:String )    {            let pluginResult = CDVPluginResult(status:CDVCommandStatus_ERROR, messageAs: message  )            commandDelegate!.send(pluginResult, callbackId: callBackIdx)    }                func call_back(_ callBackIdx:String,message:String )    {        let pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: message  )        commandDelegate!.send(pluginResult, callbackId: callBackIdx)    }        }@objc protocol protocal_for_plugins        {                        func call_back(_ callBackIdx:String ,message:String);}